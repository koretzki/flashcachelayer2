    
/*
* Flash Cache Layer (FCL) (Version 1.0) 
*
* Author		: Yongseok Oh (ysoh@uos.ac.kr)
* Date			: 18/06/2012  
* Description	: 
*
*/

#include "disksim_iosim.h"
#include "modules/modules.h"
#include "disksim_fcl.h"
#include "disksim_ioqueue.h"


/* Global variables */ 
struct ioq *fcl_overall_queue = NULL;
int fcl_opid = 0;

#define fprintf 

ioreq_event *fcl_create_child (ioreq_event *parent, int devno, int blkno, int bcount, unsigned int flags){
	ioreq_event *child = NULL;

	child = ioreq_copy ( parent );
//	child  = (ioreq_event *) getfromextraq(); // DO NOT Use !!	

	child->time = parent->time;
	child->devno = devno;
	child->blkno = blkno;
	child->bcount = bcount;
	child->flags = flags;
	child->fcl_event_next = NULL;

	return child;
}

void fcl_attach_child (ioreq_event **fcl_event_list, int *fcl_event_count, int list_index,  ioreq_event *child){
	ioreq_event *last;

	int debug_count = 0;

	last = fcl_event_list[list_index];

	if ( last == NULL ) {
		fcl_event_list[list_index]= child;
	}else{
		while ( last->fcl_event_next != NULL ){
			last = last->fcl_event_next;
		}
		last->fcl_event_next = child;
	}

	child->fcl_event_next = NULL;
	//child->fcl_parent = parent;
	//child->fcl_event_ptr = list_index;

	fcl_event_count[list_index] += 1;

	/* Debug */ 
	last = fcl_event_list[list_index];

	//fprintf ( stdout, " Debug print \n" );

	while ( last != NULL ) {
		//fprintf ( stdout, " List[%d]: %p %d %d \n", list_index, last, last->blkno, last->bcount );
		last = last->fcl_event_next;
		debug_count ++;
	}

	ASSERT ( debug_count == fcl_event_count[list_index] );
}

void fcl_parent_init (ioreq_event *parent) {
	int i; 

	fcl_opid ++; 

	parent->opid = fcl_opid;
	parent->fcl_event_ptr = 0;
	parent->fcl_event_num = 0;

	for ( i = 0; i < FCL_EVENT_MAX; i++) {
		parent->fcl_event_count[i] = 0;
		parent->fcl_event_list[i] = NULL;
	}

}

void fcl_issue_next_child ( ioreq_event *parent ){
	ioreq_event *req;

	fprintf ( stdout, " issue next = %d \n", parent->fcl_event_ptr );
	fflush( stdout );
	req = parent->fcl_event_list[parent->fcl_event_ptr];

	ASSERT ( parent->fcl_event_count[parent->fcl_event_ptr] != 0 );
	ASSERT ( req != NULL);

	while ( req != NULL ){

		//fprintf ( stdout, " req blkno = %d, dev = %d, bcount = %d \n", req->blkno, req->devno, req->bcount);

		addtointq((event *) req);
		req = req->fcl_event_next;

	}

	parent->fcl_event_ptr++;

}


void fcl_split_parent_request (ioreq_event *parent, ioreq_event **fcl_event_list, int *fcl_event_count) {
	ioreq_event *child = NULL;
	int 		i, j;
	int			list_index = 0;
	int 		devno = 0;
	int page_count = parent->bcount / FCL_PAGE_SIZE;

	ASSERT ( parent->bcount % FCL_PAGE_SIZE == 0 );

	for (i = 0; i < page_count; i++){

		if ( 1 ) { // cache miss 

			for (j = 0; j < 2 ; j++ ) { 

				devno = j % 2;

				child = fcl_create_child ( parent, 
										   devno, 
										   parent->blkno + i * FCL_PAGE_SIZE, 
										   FCL_PAGE_SIZE, 
										   parent->flags ); 

				child->devno = devno;
				child->type = IO_REQUEST_ARRIVE2;
				child->time = simtime + 0.000;
				child->fcl_parent = parent;
				
				list_index = devno;

				fcl_attach_child (  fcl_event_list, 
									fcl_event_count, 
									list_index,
									child ); 
			}
		} 
	} // for 
}


int fcl_req_is_consecutive( ioreq_event *req1, ioreq_event *req2 ){

	if ( req1->blkno + req1->bcount == req2->blkno ) {
		return 1;	
	}else{
		return 0;
	}
		
}
void *fcl_make_merge_request (ioreq_event **fcl_event_list, int *fcl_event_count) {
	ioreq_event *req;
	ioreq_event *merged_req;
	int 		i;

	for ( i = 0; i < FCL_EVENT_MAX; i++ ) {

		if ( fcl_event_count[i] == 0 )  {
			continue;
		}

		req = fcl_event_list[i];

		ASSERT ( req != NULL);

		while ( req != NULL ){

			//fprintf ( stdout, " req blkno = %d, dev = %d, bcount = %d \n", req->blkno, req->devno, req->bcount);


			if (req->fcl_event_next && fcl_req_is_consecutive ( req, req->fcl_event_next )) {
				
				// assign next request to remove pointer
				merged_req = req->fcl_event_next;

				// merge two consecutive requests
				req->bcount += merged_req->bcount;	

				// remove next request 
				req->fcl_event_next = merged_req->fcl_event_next;

				addtoextraq((event *)merged_req);
				
				fcl_event_count[i] --;

			} else {
				req = req->fcl_event_next;
			}
		}
	}
	

}	

void fcl_make_child_request (ioreq_event *parent) {

	ioreq_event *fcl_event_list[FCL_EVENT_MAX];
	int 		fcl_event_count[FCL_EVENT_MAX];
	int i;

	for ( i = 0; i < FCL_EVENT_MAX; i++){
		fcl_event_list[i] = NULL;
		fcl_event_count[i] = 0;
	}

	fcl_split_parent_request ( parent, fcl_event_list, fcl_event_count );

	parent->fcl_event_ptr = 0;
	parent->fcl_event_num = 0;

	for ( i = 0; i < FCL_EVENT_MAX; i++){
		parent->fcl_event_list[i]  = fcl_event_list[i];
		parent->fcl_event_count[i] = fcl_event_count[i];
		
		if ( fcl_event_count [i] ) {
			parent->fcl_event_num ++ ;
			fprintf ( stdout, " [%d] %p %d \n", i, fcl_event_list[i], fcl_event_count[i]);
		}
	}

	fcl_make_merge_request ( parent->fcl_event_list, parent->fcl_event_count );

	
}

void fcl_request_arrive (ioreq_event *parent){
	ioreq_event *child = NULL;
	ioreq_event *temp = NULL;

	fprintf ( stdout, " FCL Req Arrive time = %f, blkno = %d, bcount = %d \n", 
										simtime, parent->blkno, parent->bcount);

	fcl_parent_init ( parent );
	
	// parent request will be splited and distributed into SSD and HDD 
	fcl_make_child_request ( parent );
	
	// issue requests to IODRIVER
	fcl_issue_next_child ( parent ); 

	// insert parent req into FCL Overall Queue 
	ioqueue_add_new_request (fcl_overall_queue, parent);
	temp = ioqueue_get_next_request (fcl_overall_queue);
	ASSERT ( temp == parent );

	//fflush ( stdout );
}

void fcl_request_complete (ioreq_event *child){
	ioreq_event *parent, *req2;
	int total_req = 0;	
	int i;

	parent = (ioreq_event *)child->fcl_parent;

	//ASSERT ( parent->fcl_event_ptr-1 == child->fcl_event_ptr );

	parent->fcl_event_count[parent->fcl_event_ptr-1]--;

	//fprintf ( stdout, " Complete %d %d %d \n", parent->fcl_event_ptr-1, parent->fcl_event_count[parent->fcl_event_ptr-1],
	//		child->blkno);
	//fprintf ( stdout, " Num = %d \n",  parent->fcl_event_num );

	// next events are remaining. 
	if ( parent->fcl_event_count[parent->fcl_event_ptr-1] == 0 &&
			parent->fcl_event_ptr < parent->fcl_event_num ) 
	{
		//fprintf ( stdout, " **Issue next Requst .. \n" );
		fcl_issue_next_child ( parent );
	}

	addtoextraq ((event *) child);

	for ( i = 0; i < parent->fcl_event_num; i++) {
		total_req += parent->fcl_event_count[i];
	}

	// all child requests are complete 
	if ( total_req  == 0 ) { 

		req2 = ioqueue_physical_access_done (fcl_overall_queue, parent);
		ASSERT (req2 != NULL);
		addtoextraq ((event *) parent);

		fprintf ( stdout, " ** Complete parent req ... %d %d %d \n", parent->blkno, parent->bcount, parent->flags);
	}

	return ;
}

void fcl_init () {

	fprintf ( stdout, " Flash Cache Layer is initializing ... \n");

	// alloc queue memory 
	//fcl_overall_queue = malloc(sizeof(ioqueue));
	fcl_overall_queue = ioqueue_createdefaultqueue();
	ioqueue_initialize (fcl_overall_queue, 0);

}

void fcl_exit () {

	fprintf ( stdout, " Flash Cache Layer is finalizing ... \n"); 

	fcl_overall_queue->printqueuestats = TRUE;
	ioqueue_printstats( &fcl_overall_queue, 1, " FCL : ");
	// free queue memory
	free (fcl_overall_queue);
}

/*
ioreq_event *fcl_make_child_request (ioreq_event *parent) {
	ioreq_event *child = NULL;
	int i, j;

	// make request list 
	for ( i = 0; i < FCL_EVENT_MAX-1; i++) { 
		for ( j = 0; j < 1; j++) {
			child = fcl_create_child ( parent, parent->devno, parent->blkno, parent->bcount, parent->flags ); 

			child->devno = i % 2;
			child->type = IO_REQUEST_ARRIVE2;
			child->time = simtime + 0.000;

			fcl_attach_child_to_parent ( parent, child ); 
		}

		parent->fcl_event_num++;
		parent->fcl_event_ptr++;

	}

	parent->fcl_event_ptr = 0;

}
*/


/*

	// make request list 
	for ( i = 0; i < FCL_EVENT_MAX-1; i++) { 
		for ( j = 0; j < 1; j++) {

			child = fcl_create_child ( parent, 
									   parent->devno, 
									   parent->blkno, 
									   parent->bcount, 
									   parent->flags ); 

			child->devno = i % 2;
			child->type = IO_REQUEST_ARRIVE2;
			child->time = simtime + 0.000;
			child->fcl_parent = parent;

			list_index = i;

			fcl_attach_child ( fcl_event_list, 
										 fcl_event_count, 
										 list_index,
										 child ); 
		}

		parent->fcl_event_num++;
		parent->fcl_event_ptr++;
	}
*/

/*
void fcl_request_complete (ioreq_event *child){
	ioreq_event *parent, *req2;
	
	parent = (ioreq_event *)child->fcl_parent;

	//fprintf ( stdout, " %d %d %d %d  \n", parent->blkno, child->blkno, parent->flags, child->flags);

	parent->fcl_req_num--;
	if (parent->fcl_req_num == 0 ) { 
		req2 = ioqueue_physical_access_done (fcl_overall_queue, parent);
		ASSERT (req2 != NULL);
		addtoextraq ((event *) parent);
		exit(0);
	}

	child->tempptr2 = NULL;
	addtoextraq ((event *) child);

}
*/

/*
	parent = ioqueue_get_specific_request (fcl_overall_queue, child);
	req2 = ioqueue_physical_access_done (fcl_overall_queue, parent);
	ASSERT (req2 != NULL);
	addtoextraq ((event *) parent);
*/


#if 0 
void fcl_request_arrive (ioreq_event *parent){
	ioreq_event *child = NULL;
	ioreq_event *temp = NULL;

	fcl_opid ++; 
	parent->opid = fcl_opid;
	parent->fcl_req_num = 1;

	child = ioreq_copy (parent);

	child->fcl_parent = parent;
	child->type = IO_REQUEST_ARRIVE2;
	child->time = simtime + 0.0000;

	ioqueue_add_new_request (fcl_overall_queue, parent);
	temp = ioqueue_get_next_request (fcl_overall_queue);

	ASSERT ( temp == parent );

	addtointq((event *) child);

	//fprintf ( stdout, " %f next = %p, prev = %p \n", simtime, child->next, child->prev);
	//fprintf ( stdout, " fcl arrive %d, %p \n", child->blkno, child);

	return;
}
#endif 
